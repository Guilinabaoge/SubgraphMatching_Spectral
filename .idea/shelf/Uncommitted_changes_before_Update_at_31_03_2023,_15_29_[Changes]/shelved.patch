Index: matching/StudyPerformance.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Created by ssunah on 12/3/18.\n//\n\n#include <functional>\n#include <map>\n#include <chrono>\n#include <future>\n#include <thread>\n#include <fstream>\n#include <numeric>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <time.h>\n\n#include \"matchingcommand.h\"\n#include \"graph/graph.h\"\n#include \"GenerateFilteringPlan.h\"\n#include \"FilterVertices.h\"\n#include \"BuildTable.h\"\n#include \"GenerateQueryPlan.h\"\n#include \"EvaluateQuery.h\"\n#include \"IO.h\"\n#include \"eigenHelper.h\"\n#include \"Experiments.h\"\n#include \"StudyPerformance.h\"\n#include \"KF/spectra.h\"\n\n\n\n#define NANOSECTOSEC(elapsed_time) ((elapsed_time)/(double)1000000000)\n#define BYTESTOMB(memory_cost) ((memory_cost)/(double)(1024 * 1024))\n//#define PRINT;\n//#define ONLYCOUNTS;\n\nsize_t StudyPerformance::enumerate(Graph* data_graph, Graph* query_graph, Edges*** edge_matrix, ui** candidates, ui* candidates_count,\n                ui* matching_order, size_t output_limit) {\n    static ui order_id = 0;\n\n    order_id += 1;\n\n    auto start = std::chrono::high_resolution_clock::now();\n\n\n\n    size_t call_count = 0;\n    size_t embedding_count = EvaluateQuery::LFTJ(data_graph, query_graph, edge_matrix, candidates, candidates_count,\n                               matching_order, output_limit, call_count).embedding_cnt;\n\n\n    auto end = std::chrono::high_resolution_clock::now();\n    double enumeration_time_in_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n#ifdef SPECTRUM\n    if (EvaluateQuery::exit_) {\n        printf(\"Spectrum Order %u status: Timeout\\n\", order_id);\n    }\n    else {\n        printf(\"Spectrum Order %u status: Complete\\n\", order_id);\n    }\n#endif\n    printf(\"Spectrum Order %u Enumerate time (seconds): %.4lf\\n\", order_id, NANOSECTOSEC(enumeration_time_in_ns));\n    printf(\"Spectrum Order %u #Embeddings: %zu\\n\", order_id, embedding_count);\n    printf(\"Spectrum Order %u Call Count: %zu\\n\", order_id, call_count);\n    printf(\"Spectrum Order %u Per Call Count Time (nanoseconds): %.4lf\\n\", order_id, enumeration_time_in_ns / (call_count == 0 ? 1 : call_count));\n\n\n    return embedding_count;\n}\n\nvoid StudyPerformance::spectrum_analysis(Graph* data_graph, Graph* query_graph, Edges*** edge_matrix, ui** candidates, ui* candidates_count,\n                       size_t output_limit, std::vector<std::vector<ui>>& spectrum, size_t time_limit_in_sec) {\n\n    for (auto& order : spectrum) {\n        std::cout << \"----------------------------\" << std::endl;\n        ui* matching_order = order.data();\n        GenerateQueryPlan::printSimplifiedQueryPlan(query_graph, matching_order);\n\n        std::future<size_t> future = std::async(std::launch::async, [data_graph, query_graph, edge_matrix, candidates, candidates_count,\n                                                                     matching_order, output_limit](){\n            return enumerate(data_graph, query_graph, edge_matrix, candidates, candidates_count, matching_order, output_limit);\n        });\n\n        std::cout << \"execute...\\n\";\n        std::future_status status;\n        do {\n            status = future.wait_for(std::chrono::seconds(time_limit_in_sec));\n            if (status == std::future_status::deferred) {\n                std::cout << \"Deferred\\n\";\n                exit(-1);\n            } else if (status == std::future_status::timeout) {\n#ifdef SPECTRUM\n                EvaluateQuery::exit_ = true;\n#endif\n            }\n        } while (status != std::future_status::ready);\n    }\n}\n\n\nmatching_algo_outputs StudyPerformance::solveGraphQuery(matching_algo_inputs inputs){\n    int argc = 0;\n    char** argv;\n    MatchingCommand command(argc, argv);\n    std::string input_query_graph_file = inputs.qgraph_path;\n    std::string input_data_graph_file = inputs.dgraph_path;\n    std::string input_filter_type = inputs.filter;\n    std::string input_order_type = inputs.order;\n    std::string input_engine_type = inputs.engine;\n    std::string input_max_embedding_num = \"MAX\";\n    std::string input_time_limit = \"300\";\n    std::string input_order_num = command.getOrderNum();\n    std::string input_distribution_file_path = command.getDistributionFilePath();\n    std::string input_csr_file_path = command.getCSRFilePath();\n    std::string input_iseigen = inputs.eigen;\n    std::string input_tops;\n    matching_algo_outputs outputs;\n    /**\n     * Output the command line information.\n     */\n#ifdef PRINT1\n    std::cout << \"Command Line:\" << std::endl;\n    std::cout << \"\\tData Graph CSR: \" << input_csr_file_path << std::endl;\n    std::cout << \"\\tData Graph: \" << input_data_graph_file << std::endl;\n    std::cout << \"\\tQuery Graph: \" << input_query_graph_file << std::endl;\n    std::cout << \"\\tFilter Type: \" << input_filter_type << std::endl;\n    std::cout << \"\\tOrder Type: \" << input_order_type << std::endl;\n    std::cout << \"\\tEngine Type: \" << input_engine_type << std::endl;\n    std::cout << \"\\tOutput Limit: \" << input_max_embedding_num << std::endl;\n    std::cout << \"\\tTime Limit (seconds): \" << input_time_limit << std::endl;\n    std::cout << \"\\tOrder Num: \" << input_order_num << std::endl;\n    std::cout << \"\\tDistribution File Path: \" << input_distribution_file_path << std::endl;\n    std::cout << \"\\tWith eigen filter?: \" << input_iseigen << std::endl;\n    std::cout << \"\\tTop-s eigen value?: \" << input_tops << std::endl;\n\n    std::cout << \"--------------------------------------------------------------------\" << std::endl;\n#endif\n    /**\n     * Load input graphs.\n     */\n#ifdef PRINT1\n    std::cout << \"Load graphs...\" << std::endl;\n#endif\n\n\n    auto start = std::chrono::high_resolution_clock::now();\n\n    Graph* query_graph = new Graph(true);\n    query_graph->loadGraphFromFile(input_query_graph_file);\n    query_graph->buildCoreTable();\n    outputs.query_size = query_graph->getVerticesCount();\n\n    Graph* data_graph = new Graph(true);\n\n    if (input_csr_file_path.empty()) {\n        if(inputs.filter!=\"KF\"){\n            data_graph->loadGraphFromFile(input_data_graph_file);\n        }\n        else{\n            data_graph->loadGraphFromFile(input_data_graph_file);\n            data_graph->BuildLabelOffset();\n        }\n\n    }\n    else {\n        std::string degree_file_path = input_csr_file_path + \"_deg.bin\";\n        std::string edge_file_path = input_csr_file_path + \"_adj.bin\";\n        std::string label_file_path = input_csr_file_path + \"_label.bin\";\n        data_graph->loadGraphFromFileCompressed(degree_file_path, edge_file_path, label_file_path);\n    }\n\n    auto end = std::chrono::high_resolution_clock::now();\n\n    double load_graphs_time_in_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n\n\n    input_tops = \"10\";\n    if(query_graph->getVerticesCount()==4) input_tops = \"4\";\n    if(query_graph->getVerticesCount()==8) input_tops = \"8\";\n\n\n#ifdef PRINT1\n    std::cout << \"-----\" << std::endl;\n    std::cout << \"Query Graph Meta Information\" << std::endl;\n    query_graph->printGraphMetaData();\n    std::cout << \"-----\" << std::endl;\n    data_graph->printGraphMetaData();\n\n    std::cout << \"--------------------------------------------------------------------\" << std::endl;\n#endif\n    /**\n     * Start queries.\n     */\n\n\n#ifdef PRINT1\n    std::cout << \"Start queries...\" << std::endl;\n    std::cout << \"-----\" << std::endl;\n    std::cout << \"Filter candidates...\" << std::endl;\n#endif\n\n    start = std::chrono::high_resolution_clock::now();\n\n    bool isEigenCheck;\n    int top_s = std::stoi( input_tops);\n    istringstream(input_iseigen) >> isEigenCheck;\n\n\n    ui** candidates = NULL;\n    ui* candidates_count = NULL;\n    ui* tso_order = NULL;\n    TreeNode* tso_tree = NULL;\n    ui* cfl_order = NULL;\n    TreeNode* cfl_tree = NULL;\n    ui* dpiso_order = NULL;\n    TreeNode* dpiso_tree = NULL;\n    TreeNode* ceci_tree = NULL;\n    ui* ceci_order = NULL;\n    std::vector<std::unordered_map<VertexID, std::vector<VertexID >>> TE_Candidates;\n    std::vector<std::vector<std::unordered_map<VertexID, std::vector<VertexID>>>> NTE_Candidates;\n    if (input_filter_type == \"LDF\") {\n        FilterVertices::LDFFilter(data_graph, query_graph, candidates, candidates_count,isEigenCheck,top_s);\n    } else if(input_filter_type==\"KF\"){\n        SpectralMatching(query_graph->getVerticesCount(), data_graph, input_query_graph_file, true,candidates,candidates_count);\n    }\n    else if (input_filter_type == \"NLF\") {\n        FilterVertices::NLFFilter(data_graph, query_graph, candidates, candidates_count,isEigenCheck,top_s);\n    } else if (input_filter_type == \"GQL\") {\n        FilterVertices::GQLFilter(data_graph, query_graph, candidates, candidates_count,isEigenCheck,top_s);\n    } else if (input_filter_type == \"TSO\") {\n        FilterVertices::TSOFilter(data_graph, query_graph, candidates, candidates_count, tso_order, tso_tree,isEigenCheck,top_s);\n    } else if (input_filter_type == \"CFL\") {\n        FilterVertices::CFLFilter(data_graph, query_graph, candidates, candidates_count, cfl_order, cfl_tree,isEigenCheck,top_s);\n    } else if (input_filter_type == \"DPiso\") {\n        FilterVertices::DPisoFilter(data_graph, query_graph, candidates, candidates_count, dpiso_order, dpiso_tree,isEigenCheck,top_s);\n    } else if (input_filter_type == \"CECI\") {\n        FilterVertices::CECIFilter(data_graph, query_graph, candidates, candidates_count, ceci_order, ceci_tree, TE_Candidates, NTE_Candidates,isEigenCheck,top_s);\n    }  else {\n        std::cout << \"The specified filter type '\" << input_filter_type << \"' is not supported.\" << std::endl;\n        exit(-1);\n    }\n\n    // Sort the candidates to support the set intersections\n    // TODO figure out why CECI doesn't work, read the paper.\n    if (input_filter_type != \"CECI\")\n        FilterVertices::sortCandidates(candidates, candidates_count, query_graph->getVerticesCount());\n\n    end = std::chrono::high_resolution_clock::now();\n    double filter_vertices_time_in_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n\n    int sum = 0;\n    outputs.candidate_count_sum = accumulate(candidates_count, candidates_count + query_graph->getVerticesCount(), sum);\n\n#ifdef ONLYCOUNTS\n    return outputs;\n#endif\n\n    for (int i=0; i<query_graph->getVerticesCount();i++){\n        outputs.candidate.push_back(set<ui>());\n    }\n\n    for (int i=0; i<query_graph->getVerticesCount();i++){\n        for(int j=0;j<candidates_count[i];j++){\n            outputs.candidate[i].insert(candidates[i][j]);\n        }\n    }\n\n\n    // Compute the candidates false positive ratio.\n#ifdef OPTIMAL_CANDIDATES\n    std::vector<ui> optimal_candidates_count;\n    double avg_false_positive_ratio = FilterVertices::computeCandidatesFalsePositiveRatio(data_graph, query_graph, candidates,\n                                                                                          candidates_count, optimal_candidates_count);\n    FilterVertices::printCandidatesInfo(query_graph, candidates_count, optimal_candidates_count);\n#endif\n\n#ifdef PRINT1\n    std::cout << \"-----\" << std::endl;\n    std::cout << \"Build indices...\" << std::endl;\n#endif\n\n    start = std::chrono::high_resolution_clock::now();\n\n    Edges ***edge_matrix = NULL;\n    if (input_filter_type != \"CECI\") {\n        edge_matrix = new Edges **[query_graph->getVerticesCount()];\n        for (ui i = 0; i < query_graph->getVerticesCount(); ++i) {\n            edge_matrix[i] = new Edges *[query_graph->getVerticesCount()];\n        }\n        BuildTable::buildTables(data_graph, query_graph, candidates, candidates_count, edge_matrix);\n    }\n\n    end = std::chrono::high_resolution_clock::now();\n    double build_table_time_in_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n\n    size_t memory_cost_in_bytes = 0;\n    if (input_filter_type != \"CECI\") {\n        memory_cost_in_bytes = BuildTable::computeMemoryCostInBytes(query_graph, candidates_count, edge_matrix);\n#ifdef PRINT1\n        BuildTable::printTableCardinality(query_graph, edge_matrix);\n#endif\n    }\n    else {\n        memory_cost_in_bytes = BuildTable::computeMemoryCostInBytes(query_graph, candidates_count, ceci_order, ceci_tree,\n                                                                    TE_Candidates, NTE_Candidates);\n#ifdef PRINT1\n        BuildTable::printTableCardinality(query_graph, ceci_tree, ceci_order, TE_Candidates, NTE_Candidates);\n#endif\n    }\n\n#ifdef PRINT1\n    std::cout << \"-----\" << std::endl;\n    std::cout << \"Generate a matching order...\" << std::endl;\n#endif\n\n    start = std::chrono::high_resolution_clock::now();\n\n    ui* matching_order = NULL;\n    ui* pivots = NULL;\n    ui** weight_array = NULL;\n\n    size_t order_num = 0;\n    sscanf(input_order_num.c_str(), \"%zu\", &order_num);\n\n    std::vector<std::vector<ui>> spectrum;\n    if (input_order_type == \"QSI\") {\n        GenerateQueryPlan::generateQSIQueryPlan(data_graph, query_graph, edge_matrix, matching_order, pivots);\n    } else if (input_order_type == \"GQL\") {\n        GenerateQueryPlan::generateGQLQueryPlan(data_graph, query_graph, candidates_count, matching_order, pivots);\n    } else if (input_order_type == \"TSO\") {\n        if (tso_tree == NULL) {\n            GenerateFilteringPlan::generateTSOFilterPlan(data_graph, query_graph, tso_tree, tso_order,top_s);\n        }\n        GenerateQueryPlan::generateTSOQueryPlan(query_graph, edge_matrix, matching_order, pivots, tso_tree, tso_order);\n    } else if (input_order_type == \"CFL\") {\n        if (cfl_tree == NULL) {\n            int level_count;\n            ui* level_offset;\n            GenerateFilteringPlan::generateCFLFilterPlan(data_graph, query_graph, cfl_tree, cfl_order, level_count, level_offset,isEigenCheck,top_s);\n            delete[] level_offset;\n        }\n        GenerateQueryPlan::generateCFLQueryPlan(data_graph, query_graph, edge_matrix, matching_order, pivots, cfl_tree, cfl_order, candidates_count);\n    } else if (input_order_type == \"DPiso\") {\n        if (dpiso_tree == NULL) {\n            GenerateFilteringPlan::generateDPisoFilterPlan(data_graph, query_graph, dpiso_tree, dpiso_order);\n        }\n\n        GenerateQueryPlan::generateDSPisoQueryPlan(query_graph, edge_matrix, matching_order, pivots, dpiso_tree, dpiso_order,\n                                                   candidates_count, weight_array);\n    }\n    else if (input_order_type == \"CECI\") {\n        GenerateQueryPlan::generateCECIQueryPlan(query_graph, ceci_tree, ceci_order, matching_order, pivots);\n    }\n    else if (input_order_type == \"RI\") {\n        GenerateQueryPlan::generateRIQueryPlan(data_graph, query_graph, matching_order, pivots);\n    }\n    else if (input_order_type == \"VF2PP\") {\n        GenerateQueryPlan::generateVF2PPQueryPlan(data_graph, query_graph, matching_order, pivots);\n    }\n    else if (input_order_type == \"Spectrum\") {\n        GenerateQueryPlan::generateOrderSpectrum(query_graph, spectrum, order_num);\n    }\n    else {\n        std::cout << \"The specified order type '\" << input_order_type << \"' is not supported.\" << std::endl;\n    }\n\n    end = std::chrono::high_resolution_clock::now();\n    double generate_query_plan_time_in_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n\n    if (input_order_type != \"Spectrum\") {\n        GenerateQueryPlan::checkQueryPlanCorrectness(query_graph, matching_order, pivots);\n#ifdef PRINT1\n        GenerateQueryPlan::printSimplifiedQueryPlan(query_graph, matching_order);\n#endif\n    }\n    else {\n#ifdef PRINT1\n        std::cout << \"Generate \" << spectrum.size() << \" matching orders.\" << std::endl;\n#endif\n\n    }\n\n#ifdef PRINT1\n    std::cout << \"-----\" << std::endl;\n    std::cout << \"Enumerate...\" << std::endl;\n#endif\n\n    //Add the matching order into return struct\n    for(int i =0; i<outputs.query_size;i++){\n        outputs.matching_order.push_back(matching_order[i]);\n    }\n\n\n    size_t output_limit = 0;\n    size_t embedding_count = 0;\n    if (input_max_embedding_num == \"MAX\") {\n        output_limit = std::numeric_limits<size_t>::max();\n    }\n    else {\n        sscanf(input_max_embedding_num.c_str(), \"%zu\", &output_limit);\n    }\n\n\n#if ENABLE_QFLITER == 1\n    EvaluateQuery::qfliter_bsr_ graph_ = BuildTable::qfliter_bsr_graph_;\n#endif\n\n    size_t call_count = 0;\n    size_t time_limit = 0;\n    sscanf(input_time_limit.c_str(), \"%zu\", &time_limit);\n\n    start = std::chrono::high_resolution_clock::now();\n    enumResult s;\n\n    if (input_engine_type == \"EXPLORE\") {\n        embedding_count = EvaluateQuery::exploreGraph(data_graph, query_graph, edge_matrix, candidates,\n                                                      candidates_count, matching_order, pivots, output_limit, call_count);\n    } else if (input_engine_type == \"LFTJ\") {\n\n\n        s = EvaluateQuery::LFTJ(data_graph, query_graph, edge_matrix, candidates, candidates_count,\n                                           matching_order, output_limit, call_count);\n\n        embedding_count = s.embedding_cnt;\n\n\n    } else if (input_engine_type == \"GQL\") {\n        s = EvaluateQuery::exploreGraphQLStyle(data_graph, query_graph, candidates, candidates_count,\n                                                             matching_order, output_limit, call_count);\n\n        embedding_count = s.embedding_cnt;\n\n    } else if (input_engine_type == \"QSI\") {\n        embedding_count = EvaluateQuery::exploreQuickSIStyle(data_graph, query_graph, candidates, candidates_count,\n                                                             matching_order, pivots, output_limit, call_count);\n    }\n    else if (input_engine_type == \"DPiso\") {\n        embedding_count = EvaluateQuery::exploreDPisoStyle(data_graph, query_graph, dpiso_tree,\n                                                           edge_matrix, candidates, candidates_count,\n                                                           weight_array, dpiso_order, output_limit,\n                                                           call_count);\n//        embedding_count = EvaluateQuery::exploreDPisoRecursiveStyle(data_graph, query_graph, dpiso_tree,\n//                                                           edge_matrix, candidates, candidates_count,\n//                                                           weight_array, dpiso_order, output_limit,\n//                                                           call_count);\n    }\n    else if (input_engine_type == \"Spectrum\") {\n        spectrum_analysis(data_graph, query_graph, edge_matrix, candidates, candidates_count, output_limit, spectrum, time_limit);\n    }\n    else if (input_engine_type == \"CECI\") {\n        embedding_count = EvaluateQuery::exploreCECIStyle(data_graph, query_graph, ceci_tree, candidates, candidates_count, TE_Candidates,\n                                                          NTE_Candidates, ceci_order, output_limit, call_count);\n    }\n    else {\n        std::cout << \"The specified engine type '\" << input_engine_type << \"' is not supported.\" << std::endl;\n        exit(-1);\n    }\n\n    end = std::chrono::high_resolution_clock::now();\n    double enumeration_time_in_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n\n\n    outputs.enumOutput = s;\n//    bool isvalid_candidates = Experiments::candidate_set_correctness_check(outputs.candidate,s.candidate_true,query_graph->getVerticesCount());\n//\n//    if(!isvalid_candidates) throw invalid_argument(\"Invalid candidate set, false negative occurs.\");\n\n#ifdef DISTRIBUTION\n    std::ofstream outfile (input_distribution_file_path , std::ofstream::binary);\n    outfile.write((char*)EvaluateQuery::distribution_count_, sizeof(size_t) * data_graph->getVerticesCount());\n    delete[] EvaluateQuery::distribution_count_;\n#endif\n\n#ifdef PRINT1\n    std::cout << \"--------------------------------------------------------------------\" << std::endl;\n    std::cout << \"Release memories...\" << std::endl;\n#endif\n    /**\n     * Release the allocated memories.\n     */\n    delete[] candidates_count;\n    delete[] tso_order;\n    delete[] tso_tree;\n    delete[] cfl_order;\n    delete[] cfl_tree;\n    delete[] dpiso_order;\n    delete[] dpiso_tree;\n    delete[] ceci_order;\n    delete[] ceci_tree;\n    delete[] matching_order;\n    delete[] pivots;\n    for (ui i = 0; i < query_graph->getVerticesCount(); ++i) {\n        delete[] candidates[i];\n    }\n    delete[] candidates;\n\n    if (edge_matrix != NULL) {\n        for (ui i = 0; i < query_graph->getVerticesCount(); ++i) {\n            for (ui j = 0; j < query_graph->getVerticesCount(); ++j) {\n                delete edge_matrix[i][j];\n            }\n            delete[] edge_matrix[i];\n        }\n        delete[] edge_matrix;\n    }\n    if (weight_array != NULL) {\n        for (ui i = 0; i < query_graph->getVerticesCount(); ++i) {\n            delete[] weight_array[i];\n        }\n        delete[] weight_array;\n    }\n\n    delete query_graph;\n    delete data_graph;\n\n    /**\n     * End.\n     */\n\n    double preprocessing_time_in_ns = filter_vertices_time_in_ns + build_table_time_in_ns + generate_query_plan_time_in_ns;\n    double total_time_in_ns = preprocessing_time_in_ns + enumeration_time_in_ns;\n    outputs.total_time = NANOSECTOSEC(total_time_in_ns);\n    outputs.preprocessing_time = NANOSECTOSEC(preprocessing_time_in_ns);\n    outputs.enumeration_time = NANOSECTOSEC(enumeration_time_in_ns);\n#ifdef PRINT\n    std::cout << \"--------------------------------------------------------------------\" << std::endl;\n    printf(\"Load graphs time (seconds): %.4lf\\n\", NANOSECTOSEC(load_graphs_time_in_ns));\n    printf(\"Filter vertices time (seconds): %.4lf\\n\", NANOSECTOSEC(filter_vertices_time_in_ns));\n    printf(\"Build table time (seconds): %.4lf\\n\", NANOSECTOSEC(build_table_time_in_ns));\n    printf(\"Generate query plan time (seconds): %.4lf\\n\", NANOSECTOSEC(generate_query_plan_time_in_ns));\n    printf(\"Enumerate time (seconds): %.4lf\\n\", NANOSECTOSEC(enumeration_time_in_ns));\n    printf(\"Preprocessing time (seconds): %.4lf\\n\", NANOSECTOSEC(preprocessing_time_in_ns));\n    printf(\"Total time (seconds): %.4lf\\n\", NANOSECTOSEC(total_time_in_ns));\n    printf(\"Memory cost (MB): %.4lf\\n\", BYTESTOMB(memory_cost_in_bytes));\n    printf(\"#Embeddings: %zu\\n\", embedding_count);\n    printf(\"Call Count: %zu\\n\", call_count);\n    printf(\"Candidate count sum %zu\\n\",outputs.candidate_count_sum);\n    printf(\"Candidate true sum so far %zu\\n\",outputs.enumOutput.candidate_true_count_sum);\n    printf(\"Per Call Count Time (nanoseconds): %.4lf\\n\", enumeration_time_in_ns / (call_count == 0 ? 1 : call_count));\n    std::cout << \"End.\" << std::endl;\n#endif\n    return outputs;\n}\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/matching/StudyPerformance.cpp b/matching/StudyPerformance.cpp
--- a/matching/StudyPerformance.cpp	(revision b104fee6f8a1506dd6d9a4cff0526d0f003825c8)
+++ b/matching/StudyPerformance.cpp	(date 1678455570181)
@@ -108,7 +108,7 @@
     std::string input_filter_type = inputs.filter;
     std::string input_order_type = inputs.order;
     std::string input_engine_type = inputs.engine;
-    std::string input_max_embedding_num = "MAX";
+    std::string input_max_embedding_num = "500000000";
     std::string input_time_limit = "300";
     std::string input_order_num = command.getOrderNum();
     std::string input_distribution_file_path = command.getDistributionFilePath();
Index: matching/main.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Created by zhiwei zeng on 25/02/2023.\n//\n#include <chrono>\n#include <future>\n#include <thread>\n#include <fstream>\n#include <iostream>\n#include <string>\n\n#include \"graph/graph.h\"\n#include \"FilterVertices.h\"\n#include \"IO.h\"\n#include \"eigenHelper.h\"\n#include \"Experiments.h\"\n#include \"StudyPerformance.h\"\n\nvoid generate_datagraph_eigenvector(string data_graph_path,string csvfilename){\n    Graph* data_graph = new Graph(true);\n    data_graph->loadGraphFromFile(data_graph_path);\n\n    MatrixXd datagraph_eigenvalue(data_graph->getVerticesCount(), 35);\n    cout<<\"Start compute eigen value\"<<endl;\n    MTcalc12(data_graph,data_graph->getGraphMaxDegree(),datagraph_eigenvalue,true,35);\n    saveData(csvfilename, datagraph_eigenvalue);\n\n}\n\n\nint main(int argc, char** argv) {\n    //    generate_datagraph_eigenvector(\"../../test/reallife_dataset/eu2005/data_graph/eu2005.graph\",\"eu2005.csv\");\n\n\n    for(int i=0; i<5;i++){\n        for(int j=1;j<201;j++){\n            //yeast,hprd,uspatents,youtube,dblp,eu2005,\n            vector<string> query_size_dense_1 = {\"4\",\"8\",\"16\",\"24\",\"32\"};\n            vector<string> query_size_sparse_1 = {\"8\",\"16\",\"24\",\"32\"};\n\n            //human,wordnet\n            vector<string> query_size_dense_2 = {\"4\",\"8\",\"12\",\"16\",\"20\"};\n            vector<string> query_size_sparse_2 = {\"8\",\"12\",\"16\",\"20\"};\n\n\n            Experiments::datagraphEigenMatrix = \"wordnet.csv\";\n            queryMeta meta;\n            meta.dataset = \"wordnet\";\n            meta.query_property = \"dense\";\n            meta.query_size = query_size_dense_2[i];\n            meta.query_number = to_string(j);\n\n            std::ostringstream data;\n            data << \"../../test/reallife_dataset/\" << meta.dataset << \"/data_graph/\" << meta.dataset << \".graph\";\n            meta.data_graph_path = data.str();\n\n            std::ostringstream query;\n            query << \"../../test/reallife_dataset/\" << meta.dataset << \"/query_graph/query_\" << meta.query_property << \"_\"\n            << meta.query_size << \"_\" << meta.query_number << \".graph\";\n            meta.query_path = query.str();\n\n\n            //Query_Name,LDF,LDF+EF,NLF,NLF+EF,GQL,GQL+EF,TSOF,TSOF+EF,CFL,CFL+EF,DPiso,DPiso+EF,KF\n\n            matching_algo_outputs LDF = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"LDF\",\"0\");\n            matching_algo_outputs LDF_EF = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"LDF\",\"1\");\n            matching_algo_outputs NLF = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"NLF\",\"0\");\n            matching_algo_outputs NLF_EF = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"NLF\",\"1\");\n            matching_algo_outputs GQL = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"GQL\",\"0\");\n            matching_algo_outputs GQL_EF = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"GQL\",\"1\");\n            matching_algo_outputs TSOF = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"TSO\",\"0\");\n            matching_algo_outputs TSOF_EF = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"TSO\",\"1\");\n            matching_algo_outputs CFL = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"CFL\",\"0\");\n            matching_algo_outputs CFL_EF = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"CFL\",\"1\");\n            matching_algo_outputs DPiso = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"DPiso\",\"0\");\n            matching_algo_outputs DPiso_EF =Experiments::experiment3(meta.data_graph_path,meta.query_path,\"DPiso\",\"1\");\n            matching_algo_outputs KF =Experiments::experiment3(meta.data_graph_path,meta.query_path,\"KF\",\"0\");\n\n            std::ostringstream oss;\n            oss <<meta.query_property<<\"_\"<<meta.query_size<<\"_\"<<meta.query_number<<\",\" <<LDF.total_time<<\",\" <<LDF_EF.total_time\n            <<\",\"<<NLF.total_time<<\",\" <<NLF_EF.total_time<<\",\"<<GQL.total_time<<\",\" <<GQL_EF.total_time<<\",\" <<TSOF.total_time<<\",\" <<TSOF_EF.total_time<<\",\" <<CFL.total_time\n            <<\",\" <<CFL_EF.total_time<<\",\"<<DPiso.total_time<<\",\" <<DPiso_EF.total_time<<\",\" <<KF.total_time<<\",\"<<LDF.enumOutput.embedding_cnt<<\",\"<<LDF_EF.enumOutput.embedding_cnt\n            <<\",\"<<NLF.enumOutput.embedding_cnt<<\",\"<<NLF_EF.enumOutput.embedding_cnt<<\",\"<<GQL.enumOutput.embedding_cnt\n            <<\",\"<<GQL_EF.enumOutput.embedding_cnt<<\",\"<<TSOF.enumOutput.embedding_cnt<<\",\"<<TSOF_EF.enumOutput.embedding_cnt<<\",\"<<CFL.enumOutput.embedding_cnt\n            <<\",\"<<CFL_EF.enumOutput.embedding_cnt<<\",\"<<DPiso.enumOutput.embedding_cnt<<\",\"<<DPiso_EF.enumOutput.embedding_cnt<<\",\"<<KF.enumOutput.embedding_cnt\n            <<\",\"<<LDF.candidate_count_sum<<\",\"<<LDF.enumOutput.candidate_true_count_sum<<\",\"<<LDF_EF.candidate_count_sum<<\",\"<<LDF_EF.enumOutput.candidate_true_count_sum\n            <<\",\"<<NLF.candidate_count_sum<<\",\"<<NLF.enumOutput.candidate_true_count_sum<<\",\"<<NLF_EF.candidate_count_sum<<\",\"<<NLF_EF.enumOutput.candidate_true_count_sum\n            <<\",\"<<GQL.candidate_count_sum<<\",\"<<GQL.enumOutput.candidate_true_count_sum<<\",\"<<GQL_EF.candidate_count_sum<<\",\"<<GQL_EF.enumOutput.candidate_true_count_sum\n            <<\",\"<<TSOF.candidate_count_sum<<\",\"<<TSOF.enumOutput.candidate_true_count_sum<<\",\"<<TSOF_EF.candidate_count_sum<<\",\"<<TSOF_EF.enumOutput.candidate_true_count_sum\n            <<\",\"<<CFL.candidate_count_sum<<\",\"<<CFL.enumOutput.candidate_true_count_sum<<\",\"<<CFL_EF.candidate_count_sum<<\",\"<<CFL_EF.enumOutput.candidate_true_count_sum\n            <<\",\"<<DPiso.candidate_count_sum<<\",\"<<DPiso.enumOutput.candidate_true_count_sum<<\",\"<<DPiso_EF.candidate_count_sum<<\",\"<<DPiso_EF.enumOutput.candidate_true_count_sum\n            <<\",\"<<KF.candidate_count_sum<<\",\"<<KF.enumOutput.candidate_true_count_sum;\n\n            std::string var = oss.str();\n\n            cout<<var<<endl;\n\n            std::ofstream myfile;\n            myfile.open (\"performance_experiment/wordnet.csv\",std::ios_base::app);\n            myfile<<var<<\"\\n\";\n            myfile.close();\n        }\n    }\n\n\n}\n\n\n\n//for(int i=2; i<5;i++){\n//    for(int j=10;j<11;j++){\n//        //yeast,hprd,uspatents,youtube,dblp,eu2005,\n//        vector<string> query_size_dense_1 = {\"4\",\"8\",\"16\",\"24\",\"32\"};\n//        vector<string> query_size_sparse_1 = {\"8\",\"16\",\"24\",\"32\"};\n//\n//        //human,wordnet\n//        vector<string> query_size_dense_2 = {\"4\",\"8\",\"12\",\"16\",\"20\"};\n//        vector<string> query_size_sparse_2 = {\"8\",\"12\",\"16\",\"20\"};\n//\n//\n//        Experiments::datagraphEigenMatrix = \"youtube.csv\";\n//        queryMeta meta;\n//        meta.dataset = \"youtube\";\n//        meta.query_property = \"dense\";\n//        meta.query_size = query_size_dense_1[i];\n//        meta.query_number = to_string(j);\n//\n//        std::ostringstream data;\n//        data << \"../../test/reallife_dataset/\" << meta.dataset << \"/data_graph/\" << meta.dataset << \".graph\";\n//        meta.data_graph_path = data.str();\n//\n//        std::ostringstream query;\n//        query << \"../../test/reallife_dataset/\" << meta.dataset << \"/query_graph/query_\" << meta.query_property << \"_\"\n//        << meta.query_size << \"_\" << meta.query_number << \".graph\";\n//        meta.query_path = query.str();\n//\n//\n//        //Query_Name,LDF,LDF+EF,NLF,NLF+EF,GQL,GQL+EF,TSOF,TSOF+EF,CFL,CFL+EF,DPiso,DPiso+EF,KF\n//\n//        matching_algo_outputs LDF = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"LDF\",\"0\");\n//        matching_algo_outputs LDF_EF = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"LDF\",\"1\");\n//        matching_algo_outputs NLF = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"NLF\",\"0\");\n//        matching_algo_outputs NLF_EF = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"NLF\",\"1\");\n//        matching_algo_outputs GQL = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"GQL\",\"0\");\n//        matching_algo_outputs GQL_EF = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"GQL\",\"1\");\n//        matching_algo_outputs TSOF = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"TSO\",\"0\");\n//        matching_algo_outputs TSOF_EF = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"TSO\",\"1\");\n//        matching_algo_outputs CFL = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"CFL\",\"0\");\n//        matching_algo_outputs CFL_EF = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"CFL\",\"1\");\n//        matching_algo_outputs DPiso = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"DPiso\",\"0\");\n//        matching_algo_outputs DPiso_EF =Experiments::experiment3(meta.data_graph_path,meta.query_path,\"DPiso\",\"1\");\n//        matching_algo_outputs KF =Experiments::experiment3(meta.data_graph_path,meta.query_path,\"KF\",\"0\");\n//\n//        std::ostringstream oss;\n//        oss <<meta.query_property<<\"_\"<<meta.query_size<<\"_\"<<meta.query_number<<\",\" <<LDF.total_time<<\",\" <<LDF_EF.total_time\n//        <<\",\"<<NLF.total_time<<\",\" <<NLF_EF.total_time<<\",\"<<GQL.total_time<<\",\" <<GQL_EF.total_time<<\",\" <<TSOF.total_time<<\",\" <<TSOF_EF.total_time<<\",\" <<CFL.total_time\n//        <<\",\" <<CFL_EF.total_time<<\",\"<<DPiso.total_time<<\",\" <<DPiso_EF.total_time<<\",\" <<KF.total_time<<\",\"<<LDF.enumOutput.embedding_cnt<<\",\"<<LDF_EF.enumOutput.embedding_cnt\n//        <<\",\"<<NLF.enumOutput.embedding_cnt<<\",\"<<NLF_EF.enumOutput.embedding_cnt<<\",\"<<GQL.enumOutput.embedding_cnt\n//        <<\",\"<<GQL_EF.enumOutput.embedding_cnt<<\",\"<<TSOF.enumOutput.embedding_cnt<<\",\"<<TSOF_EF.enumOutput.embedding_cnt<<\",\"<<CFL.enumOutput.embedding_cnt\n//        <<\",\"<<CFL_EF.enumOutput.embedding_cnt<<\",\"<<DPiso.enumOutput.embedding_cnt<<\",\"<<DPiso_EF.enumOutput.embedding_cnt<<\",\"<<KF.enumOutput.embedding_cnt\n//        <<\",\"<<LDF.candidate_count_sum<<\",\"<<LDF.enumOutput.candidate_true_count_sum<<\",\"<<LDF_EF.candidate_count_sum<<\",\"<<LDF_EF.enumOutput.candidate_true_count_sum\n//        <<\",\"<<NLF.candidate_count_sum<<\",\"<<NLF.enumOutput.candidate_true_count_sum<<\",\"<<NLF_EF.candidate_count_sum<<\",\"<<NLF_EF.enumOutput.candidate_true_count_sum\n//        <<\",\"<<GQL.candidate_count_sum<<\",\"<<GQL.enumOutput.candidate_true_count_sum<<\",\"<<GQL_EF.candidate_count_sum<<\",\"<<GQL_EF.enumOutput.candidate_true_count_sum\n//        <<\",\"<<TSOF.candidate_count_sum<<\",\"<<TSOF.enumOutput.candidate_true_count_sum<<\",\"<<TSOF_EF.candidate_count_sum<<\",\"<<TSOF_EF.enumOutput.candidate_true_count_sum\n//        <<\",\"<<CFL.candidate_count_sum<<\",\"<<CFL.enumOutput.candidate_true_count_sum<<\",\"<<CFL_EF.candidate_count_sum<<\",\"<<CFL_EF.enumOutput.candidate_true_count_sum\n//        <<\",\"<<DPiso.candidate_count_sum<<\",\"<<DPiso.enumOutput.candidate_true_count_sum<<\",\"<<DPiso_EF.candidate_count_sum<<\",\"<<DPiso_EF.enumOutput.candidate_true_count_sum\n//        <<\",\"<<KF.candidate_count_sum<<\",\"<<KF.enumOutput.candidate_true_count_sum;\n//\n//        std::string var = oss.str();\n//\n//        cout<<var<<endl;\n//\n//        std::ofstream myfile;\n//        myfile.open (\"performance_experiment/youtube.csv\",std::ios_base::app);\n//        myfile<<var<<\"\\n\";\n//        myfile.close();\n//    }\n//}\n\n//\n//for(int i=4; i<5;i++){\n//for(int j=1;j<36;j++){\n////yeast,hprd,uspatents,youtube,dblp,eu2005,\n//vector<string> query_size_dense_1 = {\"4\",\"8\",\"16\",\"24\",\"32\"};\n//vector<string> query_size_sparse_1 = {\"8\",\"16\",\"24\",\"32\"};\n//\n////human,wordnet\n//vector<string> query_size_dense_2 = {\"4\",\"8\",\"12\",\"16\",\"20\"};\n//vector<string> query_size_sparse_2 = {\"8\",\"12\",\"16\",\"20\"};\n//\n//\n//Experiments::datagraphEigenMatrix = \"wordnet.csv\";\n//queryMeta meta;\n//meta.dataset = \"wordnet\";\n//meta.query_property = \"dense\";\n//meta.query_size = query_size_dense_2[i];\n//meta.query_number = to_string(j);\n//\n//std::ostringstream data;\n//data << \"../../test/reallife_dataset/\" << meta.dataset << \"/data_graph/\" << meta.dataset << \".graph\";\n//meta.data_graph_path = data.str();\n//\n//std::ostringstream query;\n//query << \"../../test/reallife_dataset/\" << meta.dataset << \"/query_graph/query_\" << meta.query_property << \"_\"\n//<< meta.query_size << \"_\" << meta.query_number << \".graph\";\n//meta.query_path = query.str();\n//\n//\n////Query_Name,LDF,LDF+EF,NLF,NLF+EF,GQL,GQL+EF,TSOF,TSOF+EF,CFL,CFL+EF,DPiso,DPiso+EF,KF\n//\n//matching_algo_outputs LDF = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"LDF\",\"0\");\n//matching_algo_outputs LDF_EF = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"LDF\",\"1\");\n//matching_algo_outputs NLF = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"NLF\",\"0\");\n//matching_algo_outputs NLF_EF = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"NLF\",\"1\");\n//matching_algo_outputs GQL = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"GQL\",\"0\");\n//matching_algo_outputs GQL_EF = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"GQL\",\"1\");\n//matching_algo_outputs TSOF = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"TSO\",\"0\");\n//matching_algo_outputs TSOF_EF = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"TSO\",\"1\");\n//matching_algo_outputs CFL = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"CFL\",\"0\");\n//matching_algo_outputs CFL_EF = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"CFL\",\"1\");\n//matching_algo_outputs DPiso = Experiments::experiment3(meta.data_graph_path,meta.query_path,\"DPiso\",\"0\");\n//matching_algo_outputs DPiso_EF =Experiments::experiment3(meta.data_graph_path,meta.query_path,\"DPiso\",\"1\");\n//matching_algo_outputs KF =Experiments::experiment3(meta.data_graph_path,meta.query_path,\"KF\",\"0\");\n//\n//std::ostringstream oss;\n//oss <<meta.query_property<<\"_\"<<meta.query_size<<\"_\"<<meta.query_number\n//<<\",\"<<LDF.candidate_count_sum<<\",\"<<LDF_EF.candidate_count_sum\n//<<\",\"<<NLF.candidate_count_sum<<\",\"<<NLF_EF.candidate_count_sum\n//<<\",\"<<GQL.candidate_count_sum<<\",\"<<GQL_EF.candidate_count_sum\n//<<\",\"<<TSOF.candidate_count_sum<<\",\"<<TSOF_EF.candidate_count_sum\n//<<\",\"<<CFL.candidate_count_sum<<\",\"<<CFL_EF.candidate_count_sum\n//<<\",\"<<DPiso.candidate_count_sum<<\",\"<<DPiso_EF.candidate_count_sum;\n//\n//std::string var = oss.str();\n//\n//cout<<var<<endl;\n//\n//std::ofstream myfile;\n//myfile.open (\"pruning_power_experiment/wordnet.csv\",std::ios_base::app);\n//myfile<<var<<\"\\n\";\n//myfile.close();\n//}\n//}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/matching/main.cpp b/matching/main.cpp
--- a/matching/main.cpp	(revision b104fee6f8a1506dd6d9a4cff0526d0f003825c8)
+++ b/matching/main.cpp	(date 1678455800156)
@@ -31,75 +31,71 @@
     //    generate_datagraph_eigenvector("../../test/reallife_dataset/eu2005/data_graph/eu2005.graph","eu2005.csv");
 
 
-    for(int i=0; i<5;i++){
-        for(int j=1;j<201;j++){
-            //yeast,hprd,uspatents,youtube,dblp,eu2005,
-            vector<string> query_size_dense_1 = {"4","8","16","24","32"};
-            vector<string> query_size_sparse_1 = {"8","16","24","32"};
+    //yeast,hprd,uspatents,youtube,dblp,eu2005,
+    vector<string> query_size_dense_1 = {"4","8","16","24","32"};
+    vector<string> query_size_sparse_1 = {"8","16","24","32"};
 
-            //human,wordnet
-            vector<string> query_size_dense_2 = {"4","8","12","16","20"};
-            vector<string> query_size_sparse_2 = {"8","12","16","20"};
+    //human,wordnet
+    vector<string> query_size_dense_2 = {"4","8","12","16","20"};
+    vector<string> query_size_sparse_2 = {"8","12","16","20"};
 
 
-            Experiments::datagraphEigenMatrix = "wordnet.csv";
-            queryMeta meta;
-            meta.dataset = "wordnet";
-            meta.query_property = "dense";
-            meta.query_size = query_size_dense_2[i];
-            meta.query_number = to_string(j);
+    Experiments::datagraphEigenMatrix = "wordnet.csv";
+    queryMeta meta;
+    meta.dataset = "wordnet";
+    meta.query_property = "dense";
+    meta.query_size = query_size_dense_2[4];
+    meta.query_number = "3";
 
-            std::ostringstream data;
-            data << "../../test/reallife_dataset/" << meta.dataset << "/data_graph/" << meta.dataset << ".graph";
-            meta.data_graph_path = data.str();
+    std::ostringstream data;
+    data << "../../test/reallife_dataset/" << meta.dataset << "/data_graph/" << meta.dataset << ".graph";
+    meta.data_graph_path = data.str();
 
-            std::ostringstream query;
-            query << "../../test/reallife_dataset/" << meta.dataset << "/query_graph/query_" << meta.query_property << "_"
-            << meta.query_size << "_" << meta.query_number << ".graph";
-            meta.query_path = query.str();
+    std::ostringstream query;
+    query << "../../test/reallife_dataset/" << meta.dataset << "/query_graph/query_" << meta.query_property << "_"
+    << meta.query_size << "_" << meta.query_number << ".graph";
+    meta.query_path = query.str();
 
 
-            //Query_Name,LDF,LDF+EF,NLF,NLF+EF,GQL,GQL+EF,TSOF,TSOF+EF,CFL,CFL+EF,DPiso,DPiso+EF,KF
+    //Query_Name,LDF,LDF+EF,NLF,NLF+EF,GQL,GQL+EF,TSOF,TSOF+EF,CFL,CFL+EF,DPiso,DPiso+EF,KF
 
-            matching_algo_outputs LDF = Experiments::experiment3(meta.data_graph_path,meta.query_path,"LDF","0");
-            matching_algo_outputs LDF_EF = Experiments::experiment3(meta.data_graph_path,meta.query_path,"LDF","1");
-            matching_algo_outputs NLF = Experiments::experiment3(meta.data_graph_path,meta.query_path,"NLF","0");
-            matching_algo_outputs NLF_EF = Experiments::experiment3(meta.data_graph_path,meta.query_path,"NLF","1");
-            matching_algo_outputs GQL = Experiments::experiment3(meta.data_graph_path,meta.query_path,"GQL","0");
-            matching_algo_outputs GQL_EF = Experiments::experiment3(meta.data_graph_path,meta.query_path,"GQL","1");
-            matching_algo_outputs TSOF = Experiments::experiment3(meta.data_graph_path,meta.query_path,"TSO","0");
-            matching_algo_outputs TSOF_EF = Experiments::experiment3(meta.data_graph_path,meta.query_path,"TSO","1");
-            matching_algo_outputs CFL = Experiments::experiment3(meta.data_graph_path,meta.query_path,"CFL","0");
-            matching_algo_outputs CFL_EF = Experiments::experiment3(meta.data_graph_path,meta.query_path,"CFL","1");
-            matching_algo_outputs DPiso = Experiments::experiment3(meta.data_graph_path,meta.query_path,"DPiso","0");
-            matching_algo_outputs DPiso_EF =Experiments::experiment3(meta.data_graph_path,meta.query_path,"DPiso","1");
-            matching_algo_outputs KF =Experiments::experiment3(meta.data_graph_path,meta.query_path,"KF","0");
+    matching_algo_outputs LDF = Experiments::experiment3(meta.data_graph_path,meta.query_path,"LDF","0");
+    matching_algo_outputs LDF_EF = Experiments::experiment3(meta.data_graph_path,meta.query_path,"LDF","1");
+    matching_algo_outputs NLF = Experiments::experiment3(meta.data_graph_path,meta.query_path,"NLF","0");
+    matching_algo_outputs NLF_EF = Experiments::experiment3(meta.data_graph_path,meta.query_path,"NLF","1");
+    matching_algo_outputs GQL = Experiments::experiment3(meta.data_graph_path,meta.query_path,"GQL","0");
+    matching_algo_outputs GQL_EF = Experiments::experiment3(meta.data_graph_path,meta.query_path,"GQL","1");
+    matching_algo_outputs TSOF = Experiments::experiment3(meta.data_graph_path,meta.query_path,"TSO","0");
+    matching_algo_outputs TSOF_EF = Experiments::experiment3(meta.data_graph_path,meta.query_path,"TSO","1");
+    matching_algo_outputs CFL = Experiments::experiment3(meta.data_graph_path,meta.query_path,"CFL","0");
+    matching_algo_outputs CFL_EF = Experiments::experiment3(meta.data_graph_path,meta.query_path,"CFL","1");
+    matching_algo_outputs DPiso = Experiments::experiment3(meta.data_graph_path,meta.query_path,"DPiso","0");
+    matching_algo_outputs DPiso_EF =Experiments::experiment3(meta.data_graph_path,meta.query_path,"DPiso","1");
+    matching_algo_outputs KF =Experiments::experiment3(meta.data_graph_path,meta.query_path,"KF","0");
 
-            std::ostringstream oss;
-            oss <<meta.query_property<<"_"<<meta.query_size<<"_"<<meta.query_number<<"," <<LDF.total_time<<"," <<LDF_EF.total_time
-            <<","<<NLF.total_time<<"," <<NLF_EF.total_time<<","<<GQL.total_time<<"," <<GQL_EF.total_time<<"," <<TSOF.total_time<<"," <<TSOF_EF.total_time<<"," <<CFL.total_time
-            <<"," <<CFL_EF.total_time<<","<<DPiso.total_time<<"," <<DPiso_EF.total_time<<"," <<KF.total_time<<","<<LDF.enumOutput.embedding_cnt<<","<<LDF_EF.enumOutput.embedding_cnt
-            <<","<<NLF.enumOutput.embedding_cnt<<","<<NLF_EF.enumOutput.embedding_cnt<<","<<GQL.enumOutput.embedding_cnt
-            <<","<<GQL_EF.enumOutput.embedding_cnt<<","<<TSOF.enumOutput.embedding_cnt<<","<<TSOF_EF.enumOutput.embedding_cnt<<","<<CFL.enumOutput.embedding_cnt
-            <<","<<CFL_EF.enumOutput.embedding_cnt<<","<<DPiso.enumOutput.embedding_cnt<<","<<DPiso_EF.enumOutput.embedding_cnt<<","<<KF.enumOutput.embedding_cnt
-            <<","<<LDF.candidate_count_sum<<","<<LDF.enumOutput.candidate_true_count_sum<<","<<LDF_EF.candidate_count_sum<<","<<LDF_EF.enumOutput.candidate_true_count_sum
-            <<","<<NLF.candidate_count_sum<<","<<NLF.enumOutput.candidate_true_count_sum<<","<<NLF_EF.candidate_count_sum<<","<<NLF_EF.enumOutput.candidate_true_count_sum
-            <<","<<GQL.candidate_count_sum<<","<<GQL.enumOutput.candidate_true_count_sum<<","<<GQL_EF.candidate_count_sum<<","<<GQL_EF.enumOutput.candidate_true_count_sum
-            <<","<<TSOF.candidate_count_sum<<","<<TSOF.enumOutput.candidate_true_count_sum<<","<<TSOF_EF.candidate_count_sum<<","<<TSOF_EF.enumOutput.candidate_true_count_sum
-            <<","<<CFL.candidate_count_sum<<","<<CFL.enumOutput.candidate_true_count_sum<<","<<CFL_EF.candidate_count_sum<<","<<CFL_EF.enumOutput.candidate_true_count_sum
-            <<","<<DPiso.candidate_count_sum<<","<<DPiso.enumOutput.candidate_true_count_sum<<","<<DPiso_EF.candidate_count_sum<<","<<DPiso_EF.enumOutput.candidate_true_count_sum
-            <<","<<KF.candidate_count_sum<<","<<KF.enumOutput.candidate_true_count_sum;
+    std::ostringstream oss;
+    oss <<meta.query_property<<"_"<<meta.query_size<<"_"<<meta.query_number<<"," <<LDF.total_time<<"," <<LDF_EF.total_time
+    <<","<<NLF.total_time<<"," <<NLF_EF.total_time<<","<<GQL.total_time<<"," <<GQL_EF.total_time<<"," <<TSOF.total_time<<"," <<TSOF_EF.total_time<<"," <<CFL.total_time
+    <<"," <<CFL_EF.total_time<<","<<DPiso.total_time<<"," <<DPiso_EF.total_time<<"," <<KF.total_time<<","<<LDF.enumOutput.embedding_cnt<<","<<LDF_EF.enumOutput.embedding_cnt
+    <<","<<NLF.enumOutput.embedding_cnt<<","<<NLF_EF.enumOutput.embedding_cnt<<","<<GQL.enumOutput.embedding_cnt
+    <<","<<GQL_EF.enumOutput.embedding_cnt<<","<<TSOF.enumOutput.embedding_cnt<<","<<TSOF_EF.enumOutput.embedding_cnt<<","<<CFL.enumOutput.embedding_cnt
+    <<","<<CFL_EF.enumOutput.embedding_cnt<<","<<DPiso.enumOutput.embedding_cnt<<","<<DPiso_EF.enumOutput.embedding_cnt<<","<<KF.enumOutput.embedding_cnt
+    <<","<<LDF.candidate_count_sum<<","<<LDF.enumOutput.candidate_true_count_sum<<","<<LDF_EF.candidate_count_sum<<","<<LDF_EF.enumOutput.candidate_true_count_sum
+    <<","<<NLF.candidate_count_sum<<","<<NLF.enumOutput.candidate_true_count_sum<<","<<NLF_EF.candidate_count_sum<<","<<NLF_EF.enumOutput.candidate_true_count_sum
+    <<","<<GQL.candidate_count_sum<<","<<GQL.enumOutput.candidate_true_count_sum<<","<<GQL_EF.candidate_count_sum<<","<<GQL_EF.enumOutput.candidate_true_count_sum
+    <<","<<TSOF.candidate_count_sum<<","<<TSOF.enumOutput.candidate_true_count_sum<<","<<TSOF_EF.candidate_count_sum<<","<<TSOF_EF.enumOutput.candidate_true_count_sum
+    <<","<<CFL.candidate_count_sum<<","<<CFL.enumOutput.candidate_true_count_sum<<","<<CFL_EF.candidate_count_sum<<","<<CFL_EF.enumOutput.candidate_true_count_sum
+    <<","<<DPiso.candidate_count_sum<<","<<DPiso.enumOutput.candidate_true_count_sum<<","<<DPiso_EF.candidate_count_sum<<","<<DPiso_EF.enumOutput.candidate_true_count_sum
+    <<","<<KF.candidate_count_sum<<","<<KF.enumOutput.candidate_true_count_sum;
 
-            std::string var = oss.str();
+    std::string var = oss.str();
 
-            cout<<var<<endl;
+    cout<<var<<endl;
 
-            std::ofstream myfile;
-            myfile.open ("performance_experiment/wordnet.csv",std::ios_base::app);
-            myfile<<var<<"\n";
-            myfile.close();
-        }
-    }
+//            std::ofstream myfile;
+//            myfile.open ("performance_experiment/wordnet.csv",std::ios_base::app);
+//            myfile<<var<<"\n";
+//            myfile.close();
 
 
 }
